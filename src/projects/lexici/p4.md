---
title: Largest palindrome product
index: 4
tags:
  https://img.shields.io/badge/Euler-4-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=4
  https://img.shields.io/badge/Languages-3-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=004
---

> A palindromic number reads the same both ways. The largest palindrome made
> from the product of two 2-digit numbers is $9009 = 91 Ã— 99$.  Find the
> largest palindrome made from the product of two 3-digit numbers.

### Solution

### Code

%%%

Ada
```ada
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Command_Line; use Ada.Command_Line;

procedure P4 is
  function ReverseInteger( n:Integer ) return Integer is
    reversed:Integer := 0;
    val:Integer := n;
  begin
    while val > 0 loop
      reversed := (10 * reversed) + (val mod 10);
      val := val / 10;
    end loop;
    return reversed;
  end ReverseInteger;
  function IsPalindrome ( n:Integer ) return Boolean is
  begin
    return n = ReverseInteger(n);
  end IsPalindrome;
  a:Integer := 999;
  b:Integer := 0;
  db:Integer := 0;
  max:Integer := 999;
  count:Integer := 3;
  largest:Integer := 0;
  tmp:Integer := 0;
begin
  if Argument_Count >= 1 then
    count := Integer'Value(Argument(1));
    tmp := count;
    max := 0;
    while count > 0 loop
      max := (max * 10) + 9;
      count := count - 1;
    end loop;
    count := tmp;
    a := max;
  end if;
  while a >= 10 * count loop
    if a mod 11 = 0 then
      b := max;
      db := 1;
    else
      b := 11 * (max / 11);
      db := 11;
    end if;
    while b >= a loop
      if a * b <= largest then
        exit;
      end if;
      if IsPalindrome( a * b ) = True then
        largest := a * b;
      end if;
      b := b - db;
    end loop;
    a := a - 1;
  end loop;
  Put_Line(Integer'Image(largest));
end P4;
```

Cpp
```cpp
#include <cstdlib>
#include <iostream>

int ReverseInteger(int val) {
  int reversed = 0;
  while (val > 0) {
    reversed = (10 * reversed) + (val % 10);
    val = val / 10;
  }
  return reversed;
}

int IsPalindrome(int n) { return n == ReverseInteger(n); }

int main(int argc, char *argv[]) {
  int count = 3;
  if (argc > 1) {
    count = atoi(argv[1]);
  }
  int tmp = count;
  int max = 0;
  while (tmp > 0) {
    max = (max * 10) + 9;
    tmp--;
  }
  int a = max;
  int largest = 0;
  while (a >= (10 * count)) {
    int b = 0;
    int db = 0;
    if (a % 11 == 0) {
      b = max;
      db = 1;
    } else {
      b = 11 * (max / 11);
      db = 11;
    }
    while (b >= a) {
      if (a * b <= largest) {
        break;
      } else if (IsPalindrome(a * b)) {
        largest = a * b;
      }
      b -= db;
    }
    a--;
  }
  std::cout << largest << std::endl;
}
```

Fortran
```fortran
program p4
  implicit none
  integer :: count = 3
  integer :: tmp = 3
  integer :: max = 0
  integer :: a = 0
  integer :: largest = 0
  integer :: b = 0
  integer :: db = 0
  character(len=32) :: arg
  if(command_argument_count() .ge. 1) then
    call get_command_argument(1, arg)
    read(arg,*) count
  endif
  tmp = count
  do while(tmp .gt. 0)
    max = (max * 10) + 9
    tmp = tmp - 1
  enddo
  a = max
  largest = 0
  do while (a .ge. (10*count))
    if(mod(a,11) .eq. 0) then
      b = max
      db = 1
    else
      b = 11 * (max / 11)
      db = 11
    endif
    do while(b .ge. a)
      if(a*b .le. largest) then
        exit
      elseif (is_palindrome(a*b)) then
        largest = a * b
      endif
      b = b - db
    enddo
    a = a - 1
  enddo

  print *,largest

  contains

  integer function reverse_integer(n) result(reversed)
    integer, intent(in) :: n
    integer :: val = 0
    val = n
    reversed = 0
    do while (val .gt. 0)
      reversed = (10 * reversed) + mod(val, 10)
      val = val / 10
    enddo
  endfunction

  logical function is_palindrome(n) result(tf)
    integer, intent(in) :: n
    tf = n .eq. reverse_integer(n)
  endfunction
end program p4
```

%%%
