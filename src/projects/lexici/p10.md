---
title: Summation of primes
index: 10
tags:
  https://img.shields.io/badge/Euler-10-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=10
  https://img.shields.io/badge/Languages-3-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=010
---

> The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$. Find the sum of all
> the primes below two million.

### Solution


### Code

%%%

Ada
```ada
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Numerics.Generic_Elementary_Functions;
with Ada.Command_Line; use Ada.Command_Line;

procedure P10 is
  package Value_Functions is new Ada.Numerics.Generic_Elementary_Functions (
  Standard.Float);
  use Value_Functions;
  limit:Long_Integer := 2000000;
  cross_limit:Long_Integer := 0;
  sieve:array (0 .. 2000000) of Boolean := (0 .. 2000000 => false);
  sum:Long_Integer := 0;
  n:Integer := 0;
begin
  for i in 2 .. (Integer(limit) / 2) loop
    n := i * 2;
    sieve(n) := true;
  end loop;
  cross_limit := Long_Integer(Float'Floor(Sqrt(Float(limit))));
  for i in 0 .. Integer((cross_limit - 3) / 2) loop
    n := (i * 2) + 3;
    if sieve(n) = false then
      for m in 0 .. Integer((limit - Long_Integer(n*n)) / Long_Integer(2*n)) loop
        sieve((m * 2*n) + (n*n)) := true;
      end loop;
    end if;
  end loop;
  for n in 2 .. Integer(limit) loop
    if sieve(n) = false then
      sum := sum + Long_Integer(n);
    end if;
  end loop;
  Put_Line(Long_Integer'Image(sum));
end P10;
```

Cpp
```cpp
#include <cmath>
#include <cstdlib>
#include <iostream>

int main(int argc, char *argv[]) {
  unsigned long long limit = 2000000;
  if (argc > 1) {
    limit = atoi(argv[1]);
  }
  unsigned long long cross_limit = floor(sqrt(limit));
  bool sieve[2000000] = {false};
  for (unsigned long long n = 4; n < limit; n += 2) {
    sieve[n] = true;
  }
  for (unsigned long long n = 3; n <= cross_limit; n += 2) {
    if (!sieve[n]) {
      for (unsigned long long m = n * n; m < limit; m += (2 * n)) {
        sieve[m] = true;
      }
    }
  }
  unsigned long long sum = 0;
  for (unsigned long long n = 2; n < limit; n++) {
    if (!sieve[n]) {
      sum += n;
    }
  }
  std::cout << sum << std::endl;
}
```

Fortran
```fortran
program p10
  integer(kind=8) :: limit = 2000000
  integer(kind=8) :: cross_limit = 0
  integer(kind=8) :: n, m
  integer(kind=8) :: sum = 0
  logical, dimension(2000000) :: sieve
  character(len=32) :: arg
  if(command_argument_count() .ge. 1) then
    call get_command_argument(1, arg)
    read(arg,*) limit
  endif
  cross_limit = int(sqrt(real(limit)))
  do n = 4, limit, 2
    sieve(n) = .true.
  enddo
  do n = 3, cross_limit, 2
    if (.not. sieve(n)) then
      do m = n * n, limit, (2 * n)
        sieve(m) = .true.
      enddo
    endif
  enddo
  do n = 2, limit
    if (.not. sieve(n)) then
      sum = sum + n
    endif
  enddo
  print *,sum
endprogram
```

%%%
