---
title: P1
tags:
  https://img.shields.io/badge/Euler-1-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=1
---

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we
> get 3, 5, 6 and 9. The sum of these multiples is 23.  Find the sum of all the
> multiples of 3 or 5 below 1000.

### Solution

A simple way to do this is to go through all numbers from 1 to 999 and test
whether they are divisible by 3 or by 5. But if we want to do the same for
numbers less than 1,000,000,000 that is going to take a long time.

To get a more efficient solution you could also calculate the sum of the
numbers that are divisible by 3, plus the sum of numbers divisible by 5. BUt as
you summed numbers divisible by 15 twise you would have to subtract the sum of
the numbers divisible by 15.

Lets write out some of the terms for $n=3$.
$$
3+6+9+12+\cdots+999=3(1+2+3+4+\cdots+333)
$$

We also not that $1+2+3+\cdots+p=\frac{1}{2}p(p+1)$. Using these two facts, we
are able to calculates the sum of numbers divisible by $n$ less than $t$ like
so:

$$
p = t / n\\
sum = n(p(p+1)) / 2
$$

Then the final solution will have the persudo code of

```
target=999

Function SumDivisibleBy(n)
  p=target / n
  return n*(p*(p+1)) / 2
EndFunction

Output SumDivisibleBy(3)+SumDivisibleBy(5)-SumDivisibleBy(15)
```

### Code

%%%

Ada
```ada
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Command_Line; use Ada.Command_Line;

procedure P1 is
  function SumDivisible ( n:Integer; max:Integer ) return Integer is
    p: Integer := max / n;
    ret: Integer := n * (p * (p + 1)) / 2;
  begin
    return ret;
  end SumDivisible;
  max: Integer := 999;
  val: Integer := 0;
begin
  if Argument_Count >= 1 then
    max := Integer'Value(Argument(1)) - 1;
  end if;
  val := SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max);
  Put_Line(Integer'Image(val));
end P1;
```

Bash
```bash
#!/bin/bash

SumDivisible() {
  let p=$(($2 / $1))
  echo $(( $(( $1 * $(( $p * $(( $p + 1 )))))) / 2 ))
}

let limit=999
if [[ "$1" != "" ]]; then
  let limit=$(($1 - 1))
fi

let val=$(( $(SumDivisible 3 $limit) + $(SumDivisible 5 $limit) - $(SumDivisible 15 $limit)))
printf "%d\n" $val
```

C/Cpp
```c
#include <stdio.h>
#include <stdlib.h>

int SumDivisible(int n, int max)
{
  int p = max / n;
  return n * (p * (p + 1)) / 2;
}

int main(int argc, char* argv[])
{
  int max = 999;
  if (argc > 1) {
    max = atoi(argv[1]) - 1;
  }
  int sum = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max);
  printf("%d\n", sum);
}
```

CSharp
```csharp
class P1{
  static int SumDivisible(int n, int max){
    int p = max / n;
    return n * (p * (p+1)) / 2;
  }
  static void Main(string[] args){
    int max = 999;
    if (args.Length >= 1){
      max = int.Parse(args[0]) - 1;
    }
    int sum = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max);
    System.Console.Write("{0}\n", sum);
  }
}
```

Fortran
```fortran
real function SumDivisible(n, max)
  integer, intent(in) :: n
  integer, intent(in) :: max
  integer :: p
  p = max / n
  p = n * (p * (p + 1)) / 2
  SumDivisible = p
end function SumDivisible

program p1
  integer :: max = 999
  integer :: sum
  character(len=32) :: arg
  if (command_argument_count() .ge. 1) then
    call get_command_argument(1, arg)
    read(arg,*) max
  end if
  sum = int(SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max))
  print *, sum
end program p1
```

FSharp
```fsharp
let SumDivisible n max : int =
  let p = max / n
  n * (p * (p + 1)) / 2

[<EntryPoint>]
let main(argv) =
  let max = if (Array.length argv > 0) then argv.[0] |> int
            else 999
  let sum = SumDivisible 3 max + SumDivisible 5 max - SumDivisible 15 max
  printfn "%i" sum
  0
```

Go
```go
package main

import "fmt"
import "os"
import "strconv"

func SumDivisible(n, max int) int {
	var p int = max / n
	return n * (p * (p + 1)) / 2
}

func main() {
	var max int = 999
	if len(os.Args) > 1 {
		if s, err := strconv.Atoi(os.Args[1]); err == nil {
			max = s - 1
		}
	}
	var sum int = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max)
	fmt.Printf("%v\n", sum)
}
```

Haskell
```haskell
import System.Environment

main = do
  args <- getArgs
  print (problem_1 (if null args then (999) else (read $ head args :: Integer)-1))

problem_1 max = sumStep 3 max + sumStep 5 max - sumStep 15 max
  where
    sumStep s n = s * sumOnetoN (n `div` s)
    sumOnetoN n = n * (n+1) `div` 2
```

JavaScript
```javascript
#!/usr/bin/env node

function SumDivisible(n, max){
  let p = Math.floor(max / n);
  return Math.floor(n * (p * ( p + 1 )) / 2);
}
let max = 999;
if (process.argv.length > 2){
  max = process.argv[2]
}
let sum = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max);
console.log(sum);
```

Lua
```lua
#!/usr/bin/lua

function SumDivisible(n, max)
  local p = math.floor(max / n)
  return math.floor(n * (p * (p + 1)) / 2)
end

function TableLength(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

max = 999

if (TableLength(arg) > 2) then
  max = arg[1] - 1
end

sum = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max)
print(sum)
```

OCaml
```ocaml
let sumdivisible a max =
  let p = max / a in
  a * (p * (p + 1 )) / 2;;

let () =
  let max = if Array.length Sys.argv > 1 then (int_of_string (Array.get Sys.argv
    1)) - 1 else 999 in
  let sum = sumdivisible 3 max + sumdivisible 5 max - sumdivisible 15 max in
  Printf.printf "%d\n" sum
```

Perl
```perl
#!/usr/bin/perl

sub SumDivisible {
  $p = int($_[1] / $_[0]);
  return (int($_[0] * ($p *( $p + 1 )) / 2));
}

$max = 999;

if (scalar(@ARGV) > 0){
  $max=$ARGV[0] - 1;
}

$sum = SumDivisible(3, $max) + SumDivisible(5, $max) - SumDivisible(15, $max);
printf $sum;
```

Python
```python
#!/usr/bin/python3

import sys

def SumDivisible(n, m):
    p = m // n;
    return n * (p * (p + 1)) // 2

def main():
    m = 999
    if len(sys.argv) > 1:
        m = int(sys.argv[1])
    s = SumDivisible(3, m) + SumDivisible(5, m) - SumDivisible(15, m)
    print(s)

if __name__ == "__main__":
    main()
```

R
```r
#!/usr/bin/Rscript

printf <- function(...) invisible(print(sprintf(...)))

SumDivisible <- function(n, max){
  p <- floor(max / n)
  floor(n * (p * (p + 1)) / 2)
}

max <- 999
args <- commandArgs(TRUE)
if (length(args) > 0){
  max <- as.integer(args[1])- 1
}
sum <- SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max)

printf("%i", sum)
```

Ruby
```ruby
#!/usr/bin/ruby -w

def SumDivisible(n, max)
  p = max / n
  return n * (p * (p + 1)) / 2
end

max = 999
if ARGV.length >= 1 then
  max = ARGV[0].to_i - 1
end
sum = SumDivisible(3, max) + SumDivisible(5, max) - SumDivisible(15, max)
puts sum.to_s;
```

Rust
```rust
use std::env;

fn sum_divisible(n: i32, max: i32) -> i32 {
    let p = max / n;
    n * (p * (p + 1)) / 2
}

fn main() {
    let mut max: i32 = 999;
    let args: Vec<_> = env::args().collect();
    if args.len() > 1 {
        max = args[1].parse().unwrap();
        max = max - 1;
    }
    let sum = sum_divisible(3, max) + sum_divisible(5, max) - sum_divisible(15, max);
    println!("{}", sum);
}
```

%%%

