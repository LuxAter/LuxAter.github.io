---
title: Smallest multiple
index: 5
tags:
  https://img.shields.io/badge/Euler-5-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=5
  https://img.shields.io/badge/Languages-3-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=005
---

> $2520$ is the smallest number that can be divided by each of the numbers from
> $1$ to $10$ without any remainder. What is the smallest positive number that
> is evenly divisible by all of the numbers from $1$ to $20$?


### Solution

### Code

%%%

Ada
```
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Numerics.Generic_Elementary_Functions;
with Ada.Command_Line; use Ada.Command_Line;

procedure P5 is
  package Value_Functions is new Ada.Numerics.Generic_Elementary_Functions (
  Standard.Float);
  use Value_Functions;
  k:Integer := 20;
  multiple:Integer := 1;
  i:Integer := 0;
  check:Boolean := true;
  p: array (0 .. 49) of Integer := (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229 );
  a:Integer := 1;
  limit:Integer := 0;
begin
  if Argument_Count >= 1 then
    k := Integer'Value(Argument(1));
  end if;
  limit := Integer(Sqrt(Float(k)));
  while p(i) <= k loop
    a := 1;
    if check then
      if p(i) <= limit then
        a := Integer(Float'Floor(Log(Float(k)) / Log(Float(p(i)))));
      else
        check := false;
      end if;
    end if;
    multiple := multiple * (p(i) ** a);
    i := i + 1;
  end loop;
  Put_Line(Integer'Image(multiple));
end P5;
```

Cpp
```cpp
#include <cmath>
#include <cstdlib>
#include <iostream>

int main(int argc, char *argv[]) {
  int k = 20;
  if (argc > 1) {
    k = atoi(argv[1]);
  }
  int multiple = 1;
  int i = 0;
  bool check = true;
  int limit = sqrt(k);
  int a[50];
  int p[50] = {2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,  41,
               43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97,  101,
               103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
               173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229};
  while (p[i] <= k) {
    a[i] = 1;
    if (check) {
      if (p[i] <= limit) {
        a[i] = floor(log(k) / log(p[i]));
      } else {
        check = false;
      }
    }
    multiple *= pow(p[i], a[i]);
    i++;
  }
  std::cout << multiple << std::endl;
}
```

Fortran
```fortran
program p5
  integer :: k = 20
  integer :: multiple = 1
  integer :: i = 0
  logical :: check = .true.
  integer :: limit = 0
  integer, dimension(50) :: a
  integer, dimension(50) :: p = (/ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,&
                                 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,&
                                 89, 97, 101, 103, 107, 109, 113, 127, 131,&
                                 137, 139, 149, 151, 157, 163, 167, 173, 179,&
                                 181, 191, 193, 197, 199, 211, 223, 227, 229 /)
  character(len=31) :: arg
  if(command_argument_count() .ge. 1) then
    call get_command_argument(1, arg)
    read(arg,*) k
  endif
  limit = int(sqrt(real(k)))
  do while(p(i) .le. k)
    a(i) = 1
    if(check) then
      if(p(i) .le. limit) then
        a(i) = int(log(real(k)) / log(real(p(i))))
      else
        check = .false.
      endif
    endif
    multiple = multiple * p(i)**a(i)
    i = i + 1
  enddo
  print *,multiple
endprogram
```

%%%
