---
title: Highly divisible triangular number 
index: 12
tags:
  https://img.shields.io/badge/Euler-12-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=12
  https://img.shields.io/badge/Languages-3-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=012
---

> The sequence of triangle numbers is generated by adding the natural numbers.
> So the $7^{th}$ triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$.
> The first ten terms would be:
> $$
> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \ldots
> $$
> Let us list the factors of the first seven triangle numbers:
> 
> * $1: 1$
> * $3: 1,3$
> * $6: 1,2,3,6$
> * $10: 1,2,5,10$
> * $15: 1,3,5,15$
> * $21: 1,3,7,21$
> * $28: 1,2,4,7,14,28$
> 
> We can see that $28$ is the first triangle number to have over five divisors.
> 
> What is the value of the first triangle number to have over five hundred
> divisors?

### Solution

### Code

%%%

Ada
```ada
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Command_Line; use Ada.Command_Line;

procedure P12 is
  type myArray is array (Integer range <>) of Integer;
  req_count :Integer := 500;
  n: Integer:= 3;
  n1: Integer:= 3;
  dn: Integer:= 2;
  dn1: Integer:= 2;
  cnt: Integer:= 0;
  p : Integer := 1;
  exponent: Integer:= 0;
  is_prime: boolean;
begin
  if Argument_Count >= 1 then
    req_count := Integer'Value(Argument(1));
  end if;
  declare
    primes: myArray(1..(req_count * 2));
  begin
    primes(1) := 2;
    for i in 3..(req_count*2) loop
      is_prime := True;
      for j in 1..p loop
        if (i mod primes(j)) = 0 then
          is_prime := False;
        end if;
        exit when is_prime = False;
      end loop;
      if is_prime then
        p := p + 1;
        primes(p) := i;
      end if;
    end loop;

    while cnt <= req_count loop
      n := n + 1;
      n1 := n;
      if (n1 mod 2) = 0 then
        n1 := n1 / 2;
      end if;
      dn1 := 1;
      is_prime := False;
      for i in 1..p loop
        if (primes(i) * primes(i)) > n1 then
          dn1 := dn1 * 2;
          is_prime := True;
        end if;
        exit when is_prime;
        exponent := 1;
        while (n1 mod primes(i)) = 0 loop
          exponent := exponent + 1;
          n1 := n1 / primes(i);
        end loop;
        if exponent > 1 then
          dn1 := dn1 * exponent;
        end if;
        if n1 = 1 then
          is_prime := True;
        end if;
        exit when is_prime;
      end loop;
      cnt := dn * dn1;
      dn := dn1;
    end loop;
  end;

  Put_Line(Integer'Image(n * (n - 1) / 2));
end P12;
```

Cpp
```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

int main(int argc, char *argv[]) {
  int req_count = 500;
  if (argc > 1) {
    req_count = atoi(argv[1]) - 1;
  }
  std::vector<unsigned> primes;
  for (unsigned i = 2; i < req_count * 2; ++i) {
    if (!std::any_of(primes.begin(), primes.end(),
                     [i](unsigned prime) { return i % prime == 0; }))
      primes.push_back(i);
  }

  unsigned n = 3;
  unsigned dn = 2;
  unsigned i, exponent;
  unsigned cnt = 0;
  while (cnt <= req_count) {
    n += 1;
    unsigned n1 = n;
    if (n1 % 2 == 0)
      n1 /= 2;
    unsigned dn1 = 1;
    for (i = 0; i < primes.size(); ++i) {
      if (primes[i] * primes[i] > n1) {
        dn1 *= 2;
        break;
      }
      exponent = 1;
      while (n1 % primes[i] == 0) {
        exponent++;
        n1 /= primes[i];
      }
      if (exponent > 1)
        dn1 *= exponent;
      if (n1 == 1)
        break;
    }
    cnt = dn * dn1;
    dn = dn1;
  }
  std::cout << n * (n - 1) / 2 << std::endl;
}
```

Fortran
```
program p12
  integer :: req_count = 500
  integer :: p = 1
  logical :: is_prime = .true.
  integer, dimension(:), allocatable :: primes

  integer :: n = 3, n1 = 3, dn = 2, dn1 = 2
  integer :: expon = 0
  integer :: cnt = 0

  character(len=32) :: arg
  if (command_argument_count() .ge. 1) then
     call get_command_argument(1, arg)
     read (arg, *) req_count
  endif
  allocate(primes(req_count*2))
  primes(0) = 2
  do i=3,(req_count*2)
    is_prime = .true.
    do j=0,(p-1)
      if (mod(i,primes(j)) .eq. 0) then
        is_prime = .false.
        exit
      endif
    enddo
    if (is_prime .eqv. .true.) then
      primes(p) = i
      p = p + 1
    endif
  enddo
  
  do while (cnt .le. req_count)
    n = n + 1
    n1 = n
    if (mod(n1, 2) .eq. 0) then
      n1 = n1 / 2
    endif
    dn1 = 1
    do i=0,(p-1)
      if((primes(i)*primes(i)) .gt. n1) then
        dn1 = dn1 * 2
        exit
      endif
      expon = 1
      do while (mod(n1, primes(i)) .eq. 0)
        expon = expon + 1
        n1 = n1 / primes(i)
      enddo
      if (expon .gt. 1) then
        dn1 = dn1 * expon 
      endif
      if (n1 .eq. 1) then
        exit
      endif
    enddo
    cnt = dn * dn1
    dn = dn1
  enddo

  print *, (n * (n-1) / 2)

end program p12
```

%%%
