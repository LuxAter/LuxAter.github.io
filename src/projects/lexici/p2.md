---
title: Even Fibonacci numbers
index: 2
tags:
  https://img.shields.io/badge/Euler-2-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=2
  https://img.shields.io/badge/Languages-16-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=002
---

> Each new term in the Fibonacci sequence is generated by adding the previous
> two terms. By starting with $1$ and $2$, the first 10 terms will be:
> $$
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots
> $$
> By considering the terms in the Fibonacci sequence whose values do not exceed
> four million, find the sum of the even-valued terms.

### Solution

A direct method would be to calculate every Fibonacci number, and if it is
even, then we add it to a running sum, only if it is even.

This can be improved upon. It becomes clear that every third Fibonacci number
will be even. This means that we can skip all the odd numbers, so that only
every third number is added.

The pseudocode of the final solution is
```
limit=4000000
sum=0
a=1
b=1
c=2
while c < limit
  sum=sum+c
  a=b+c
  b=c+a
  c=a+b
Output sum
```

### Code

%%%

Ada
```ada
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Command_Line; use Ada.Command_Line;

procedure P2 is
  limit: Integer := 4000000;
  sum: Integer := 0;
  a: Integer := 1;
  b: Integer := 1;
  c: Integer := 2;
begin
  if Argument_Count >= 1 then
    limit := Integer'Value(Argument(1));
  end if;
  while c < limit loop
    sum := sum + c;
    a := b + c;
    b := c + a;
    c := a + b;
  end loop;
  Put_Line(Integer'Image(sum));
end P2;
```

Bash
```bash
#!/bin/bash

let limit=4000000
let sum=0
let a=1
let b=1
let c=2
if [[ "$1" != "" ]]; then
  let limit=$1
fi

while [[ $c -lt $limit ]]; do
  sum=$(( sum + c ))
  a=$((b + c))
  b=$((c + a))
  c=$((a + b))
done

printf "%i\n" $sum
```

C/Cpp
```cpp
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  int limit = 4000000;
  int sum = 0;
  int a = 1;
  int b = 1;
  int c = 2;
  if (argc > 1) {
    limit = atoi(argv[1]);
  }
  while (c < limit) {
    sum += c;
    a = b + c;
    b = c + a;
    c = a + b;
  }
  printf("%d\n", sum);
}
```

CSharp
```csharp
class P2{
  static void Main(string[] args){
    int limit = 4000000;
    int sum = 0, a = 1, b = 1, c = 2;
    if (args.Length >= 1){
      limit = int.Parse(args[0]);
    }
    while (c < limit){
      sum += c;
      a = b + c;
      b = c + a;
      c = a + b;
    }
    System.Console.Write("{0}\n", sum);
  }
}
```

Fortran
```fortran
class P2{
  static void Main(string[] args){
    int limit = 4000000;
    int sum = 0, a = 1, b = 1, c = 2;
    if (args.Length >= 1){
      limit = int.Parse(args[0]);
    }
    while (c < limit){
      sum += c;
      a = b + c;
      b = c + a;
      c = a + b;
    }
    System.Console.Write("{0}\n", sum);
  }
}
```

FSharp
```fsharp
[<EntryPoint>]
let main(argv) =
  let limit = if Array.length argv > 0 then argv.[0] |> int
              else 4000000
  let mutable sum = 0
  let mutable a = 1
  let mutable b = 1
  let mutable c = 2
  while c < limit do
    sum <- sum + c
    a <- b + c
    b <- c + a
    c <- a + b
  printfn "%i" sum
  0
```

Go
```go
package main

import "fmt"
import "os"
import "strconv"

func main() {
  var limit int = 4000000
  var sum int = 0
  var a int = 1
  var b int = 1
  var c int = 2
  if len(os.Args) > 1 {
    if s, err := strconv.Atoi(os.Args[1]); err == nil {
      limit = s
    }
  }
  for c < limit {
    sum += c
    a = b + c
    b = c + a
    c = a + b
  }
  fmt.Printf("%v\n", sum)
}
```

Haskell
```haskell
import System.Environment

main = do
  args <- getArgs
  print (problem_2 (if null args then (4000000) else (read $ head args :: Integer)))

problem_2 max = sum [ x | x <- takeWhile (<= max) fibs, even x]
  where
    fibs = 1 : 1 : zipWith (+) fibs (tail fibs)

```

Javascript
```javascript
#!/usr/bin/env node

let limit = 4000000;
let sum = 0;
let a = 1;
let b = 1;
let c = 2;
if(process.argv.length > 2){
  max = process.argv[2]
}
while(c < limit){
  sum += c;
  a = b + c;
  b = c + a;
  c = a + b;
}

console.log(sum);
```

Lua
```lua
#!/usr/bin/lua

function TableLength(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

limit = 4000000
sum = 0
a = 1
b = 1
c = 2

if(TableLength(arg) > 2) then
  limit = tonumber(arg[1])
end

while(c < limit) do
  sum = sum + c
  a = b + c
  b = c + a
  c = a + b
end

print(sum)
```

OCaml
```ocaml
let rec loop a b sum limit =
  let c= a + b in
  if c > limit then sum
  else loop (b + c) (c + a) (sum + c) limit

let () =
  let limit = if Array.length Sys.argv > 1 then int_of_string (Array.get Sys.argv 1) else 4000000 in
  Printf.printf "%d\n" (loop 1 1 0 limit)
```

Perl
```perl
#!/usr/bin/perl

$limit = 4000000;
$sum = 0;
$a = 1;
$b = 1;
$c = 2;

if (scalar(@ARGV) > 0){
  $limit=$ARGV[0];
}

while($c < $limit){
  $sum += $c;
  $a = $b + $c;
  $b = $c + $a;
  $c = $a + $b;
}

printf $sum;
```

Python
```python
#!/usr/bin/python3

import sys

def main():
    limit = 4000000
    sum = 0
    a = 1
    b = 1
    c = 2
    if len(sys.argv) > 1:
        limit = int(sys.argv[1])
    while c < limit:
        sum += c
        a = b + c
        b = c + a
        c = a + b
    print(sum)

if __name__ == "__main__":
    main()
```

R
```r
#!/usr/bin/Rscript

printf <- function(...) invisible(print(sprintf(...)))

limit <- 4000000
sum <- 0
a <- 1
b <- 1
c <- 2
args <- commandArgs(TRUE)
if(length(args) > 0){
    limit <- as.integer(args[1])
}
while(c < limit){
    sum <- sum + c
    a <- b + c
    b <- c + a
    c <- a + b
}
printf("%i", sum)
```

Ruby
```ruby
#!/usr/bin/ruby -w

limit = 4000000
sum = 0
a = 1
b = 1
c = 2
if ARGV.length >= 1 then
    limit = ARGV[0].to_i
end

while c < limit do
    sum += c
    a = b + c
    b = c + a
    c = a + b
end

puts sum.to_s;
```

Rust
```rust
use std::env;

fn main() {
    let mut limit: i32 = 4000000;
    let mut sum: i32 = 0;
    let mut a: i32;
    let mut b: i32 = 1;
    let mut c: i32 = 2;
    let args: Vec<_> = env::args().collect();
    if args.len() > 1 {
        limit = args[1].parse().unwrap();
    }
    while c < limit {
        sum += c;
        a = b + c;
        b = c + a;
        c = a + b;
    }
    println!("{}", sum);
}
```

%%%
