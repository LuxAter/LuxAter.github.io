---
title: Longest Collatz sequence
index: 14
tags:
  https://img.shields.io/badge/Euler-14-brightgreen.svg?style=for-the-badge: https://projecteuler.net/problem=14
  https://img.shields.io/badge/Languages-3-blueviolet.svg?style=for-the-badge:
downloads:
  Overview: https://projecteuler.net/overview=014
---

> The following iterative sequence is defined for the set of positive integers:
> $$
> n = \begin{cases}\frac{n}{2} & \text{n is even} \\\\ 3n+1 & \text{n is
> odd}\end{cases}
> $$
> 
> Using the rule above and starting with $13$, we generate the following sequence:
> $$
> 13 \rightarrow 40 \rightarrow 20 \rightarrow 10 \rightarrow 5 \rightarrow 16
> \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1
> $$
> It can be seen that this sequence (starting at $13$ and finishing at $1$)
> contains $10$ terms. Although it has not been proved yet (Collatz Problem),
> it is thought that all starting numbers finish at $1$.
> 
> Which starting number, under one million, produces the longest chain?

**NOTE:** Once the chain starts the terms are allowed to go above one million.

### Solution

### Code

%%%

Ada
```ada
with Ada.Containers.Hashed_Maps;  use Ada.Containers;
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Hash;

procedure P14 is
  function Equivalent_Key (Left, Right : Long_Integer) return Boolean is
  begin
    return Left = Right;
  end Equivalent_Key;

  function Hash_Func(Key : Long_Integer) return Ada.Containers.Hash_Type is
  begin
    return Ada.Strings.Hash(Long_Integer'Image(key));
  end Hash_Func;

  package Hash is new Ada.Containers.Hashed_Maps (
    Key_Type => Long_Integer,
    Element_Type => Long_Integer,
    Hash => Hash_Func,
    Equivalent_Keys => Equivalent_Key
  );

  values : Hash.Map;
  maximum : Long_Integer := 1000000;
  longest : Long_Integer := 0;
  num : Long_Integer := 0;
  chain_length :Long_Integer := 0;

  function Count_Chain(n : Long_Integer) return Long_Integer is
    tmp : Long_Integer := 0;
  begin
    if Hash.Contains(values, n) then
      return Hash.Element(values, n);
    end if;
    if (n mod 2) = 0 then
      tmp := 1 + Count_Chain(n / 2);
      values.Insert(Key => n, New_Item => tmp);
    else
      tmp := 2 + Count_Chain((3 * n + 1) / 2);
      values.Insert(Key => n, New_Item => tmp);
    end if;
    return tmp;
  end Count_Chain;

begin
  if Argument_Count >= 1 then
    maximum := Long_Integer'Value(Argument(1));
  end if;
  values.Insert(Key => 1, New_Item => 1);
  for i in 2..maximum loop
    chain_length := Count_Chain(i);
    if chain_length > longest then
      longest := chain_length;
      num := i;
    end if;
  end loop;
  Put_Line(Long_Integer'Image(num));
end P14;
```

Cpp
```cpp
#include <cmath>
#include <iostream>
#include <map>

std::map<unsigned long, unsigned> values;

unsigned count_chain(unsigned long n) {
  if (values.find(n) != values.end()) {
    return values[n];
  }
  if (n % 2 == 0) {
    values[n] = 1 + count_chain(n / 2);
  } else {
    values[n] = 2 + count_chain((3 * n + 1) / 2);
  }
  return values[n];
}

int main(int argc, char *argv[]) {
  unsigned long maximum = 1000000;
  unsigned long longest = 0;
  unsigned long num = 0;
  values[1] = 1;

  if (argc > 1) {
    maximum = atoi(argv[1]);
  }

  for (unsigned long i = 2; i < maximum; ++i) {
    unsigned long chain_length = count_chain(i);
    if (chain_length > longest) {
      longest = chain_length;
      num = i;
    }
  }
  std::cout << num << std::endl;
}
```

Fortran
```fortran
program p14
  integer(kind=8) :: chain_length = 1
  integer(kind=8) :: maximum = 1000000, longest = 0, num = 0
  integer(kind=8) :: i
  character(len=32) :: arg

  if (command_argument_count() .ge. 1) then
     call get_command_argument(1, arg)
     read (arg, *) maximum 
  endif

  do i=1,maximum 
    chain_length = count_chain(i)
    if (chain_length .gt. longest) then
      longest = chain_length
      num = i
    endif
  enddo

  print *, num

  contains

  integer(kind=8) recursive function count_chain(n) result(ret)
    integer(kind=8), intent(in) :: n
    if (n .eq. 1) then
      ret = 1
      return
    endif
    if (mod(n, 2) .eq. 0) then
      ret = 1 + count_chain(n / 2)
      return
    else
      ret = 2 + count_chain((3 * n + 1) / 2)
      return 
    endif
  end function count_chain

end program p14
```

%%%
